exports.name="Pivot";exports.version="0.2";exports.handleSignals=true;exports.group=C.INTERNAL_FUNCTION_GROUP;exports.sync=true;const{NestedPropertyAccessor}=C.expr;const cLogger=C.util.getLogger("func:pivot");const NULL_FIELD="null";let labelField;let dataFields;let qualifierFields;let sourceEvents;let qualifierValues;let separator;exports.init=e=>{const t=e.conf||{};labelField=new NestedPropertyAccessor(t.labelField,cLogger);dataFields=t.dataFields.map((e=>new NestedPropertyAccessor(e,cLogger)));qualifierFields=t.qualifierFields.map((e=>new NestedPropertyAccessor(e,cLogger)));sourceEvents=[];qualifierValues=new Map;separator=dataFields.length>1?": ":""};exports.unload=()=>{labelField=undefined;dataFields=undefined;qualifierFields=undefined;sourceEvents=undefined;qualifierValues=undefined};exports.process=e=>{if(!e)return e;if(needsReset(e)){sourceEvents=[];qualifierValues=new Map;return e}if(e.__signalEvent__){cLogger.debug("flushing pivoted data");return[...pivotSourceData(),e]}sourceEvents.push(e);for(let t=0;t<qualifierFields.length;++t){const s=qualifierFields[t];const l=s.get(e)??NULL_FIELD;let r=qualifierValues.get(s.path);if(!r){r=[];qualifierValues.set(s.path,r)}if(!r.includes(l)){r.push(l)}}return null};function needsReset(e){return e.__signalEvent__==="reset"}function pivotSourceData(){if(!sourceEvents.length)return[];const e=generateFieldNames();let t=[];let s=new Map;for(let l=0;l<sourceEvents.length;++l){const r=sourceEvents[l];const i=labelField.get(r)??"";let n=t[t.length-1];if(labelField.get(n)!==i){n=s.get(i);if(!n){n=r.__clone(false,[]);labelField.deepSet(n,i);s.set(i,n);t.push(n);for(const t of e){n[t]=0}}}for(let e=0;e<dataFields.length;++e){let t=dataFields.length>1?dataFields[e].path:"";for(let e=0;e<qualifierFields.length;++e){const s=qualifierFields[e];const l=s.get(r)??NULL_FIELD;t=`${t}${e?", ":separator}${l}`}n[t]=dataFields[e].get(r)}}cLogger.info("produced pivoted output",{sourceEvents:sourceEvents.length,outputEvents:t.length,dynamicFields:e.length});sourceEvents=[];return t}function generateFieldNames(){const e=[];for(let t=0;t<dataFields.length;++t){let s=[dataFields.length>1?dataFields[t].path:""];for(let e=0;e<qualifierFields.length;++e){const t=qualifierFields[e];const l=qualifierValues.get(t.path);const r=[];for(const t of s){for(const s of l){r.push(`${t}${e?", ":separator}${s}`)}}s=r}e.push(...s)}return e}