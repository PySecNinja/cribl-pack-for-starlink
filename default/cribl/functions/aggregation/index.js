exports.name="Aggregations";exports.version="0.2";exports.disabled=false;exports.handleSignals=true;exports.group="Standard";exports.sync=true;const os=require("os");const{Expression,NestedPropertyAccessor}=C.expr;const cLogger=C.util.getLogger("func:aggregation");const hostname=os.hostname();const maxMem=os.totalmem();let passthrough=false;let aggOpts;let aggregator;let fields2add=[];let flushOnInputClose;const CTRL_PREFIX="_ctrl.";function getAccessor(e){if(e){return new NestedPropertyAccessor(e)}return e}exports.init=e=>{const s=e.conf||{};passthrough=Boolean(s.passthrough);if(!s.aggregations||!Array.isArray(s.aggregations)){return}aggOpts={cumulative:s.cumulative!==undefined?s.cumulative:false,sufficientStatsOnly:s.sufficientStatsOnly!==undefined?s.sufficientStatsOnly:false,hostname,flushEventLimit:Math.floor(s.flushEventLimit||0),timeWindowSeconds:C.util.parseTimeStringToSeconds(s.timeWindow),aggregations:s.aggregations,splitBys:s.groupbys,lagToleranceSeconds:C.util.parseTimeStringToSeconds(s.lagTolerance),idleTimeLimitSeconds:C.util.parseTimeStringToSeconds(s.idleTimeLimit),flushMemLimit:Math.min(maxMem,C.util.parseMemoryStringToBytes(s.flushMemLimit||`${maxMem}`,(e=>{throw e}))),metricsMode:Boolean(s.metricsMode),prefix:s.prefix,preserveSplitByStructure:s.preserveGroupBys||false,searchAggMode:s.searchAggMode};aggregator=C.internal.Aggregation.aggregationMgr(aggOpts);const t=[];(s.add||[]).forEach((e=>{e.name=(e.name||"").trim();const s=e.name.startsWith(CTRL_PREFIX);t.push(s);t.push(s?e.name.substr(CTRL_PREFIX.length):getAccessor(e.name));t.push(new Expression(`${e.value}`,{disallowAssign:true}))}));fields2add=t;flushOnInputClose=s.flushOnInputClose!=null?Boolean(s.flushOnInputClose):true;cLogger.info("initialized aggregation",{aggOpts,fields2add,flushOnInputClose})};function shouldForce(e){if(flushOnInputClose)return["close","final"].includes(e);return e==="final"}exports.process=e=>{if(!aggregator){return passthrough||e.__signalEvent__?e:undefined}let s;if(e.__signalEvent__&&e.__signalEvent__!=="reset"){if(e.__signalEvent__==="cancel"){s=[]}else{s=aggregator.flush(shouldForce(e.__signalEvent__))}}else{s=aggregator.aggregate(e)}if(fields2add.length){for(let e=0;e<s.length;e++){const t=s[e];for(let e=2;e<fields2add.length;e+=3){const s=fields2add[e-1];const n=fields2add[e].evalOn(t);if(!fields2add[e-2]){if(s)s.set(t,n)}else{t.__setCtrlField(s,n)}}}}if(passthrough||e.__signalEvent__&&e.__signalEvent__!=="reset"&&e.__signalEvent__!=="complete_gen"){s.push(e)}return s};exports.unload=()=>{if(aggregator){aggregator.close()}};exports.getAggOpts=()=>aggOpts;exports.getAggregator=()=>aggregator;