exports.name="XML Unroll";exports.version="0.2";exports.group="Advanced";exports.sync=true;const{NestedPropertyAccessor}=C.expr;const{XMLParser,XMLBuilder,NamedGroupRegExp,getLogger}=C.util;const cLogger=getLogger("func:xml_unroll");let unrollIdxField;let pretty=false;let copyElementRegex;let unrollElementRegex;function shouldCopyElement(e){return copyElementRegex&&copyElementRegex.test(e)}function shouldUnrollElement(e){return unrollElementRegex&&unrollElementRegex.test(e)}exports.init=e=>{const t=e.conf||{};unrollElementRegex=new NamedGroupRegExp(t.unroll.trim());unrollIdxField=new NestedPropertyAccessor(t.unrollIdxField||"unroll_idx");pretty=!!t.pretty;copyElementRegex=undefined;if(t.inherit){try{copyElementRegex=new NamedGroupRegExp(t.inherit.trim())}catch(e){cLogger.warn("failed to parse inherit regex, ignoring",{inherit:t.inherit,error:e})}}};exports.process=e=>{try{const t=e._raw;const r=new XMLParser;const n=[];let o=null;const l=[];const s=[];r.on("openTag",((e,t)=>{n.push(e);if(!o&&shouldCopyElement(n.join("."))){o=XMLBuilder.create(e);o._depth=n.length;const r=t();Object.keys(r).forEach((e=>{o.att(e,r[e])}));o._copyElement=true;return}if(!o&&shouldUnrollElement(n.join("."))){o=XMLBuilder.create(e);o._depth=n.length;const r=t();Object.keys(r).forEach((e=>{o.att(e,r[e])}))}else if(o){o=o.ele(e,t())}}));r.on("text",(e=>{if(o&&o.children.length===0){e=e.trim();if(e.length>0){o.raw(e)}}}));r.on("cdata",(e=>{if(o)o.dat(e)}));r.on("closeTag",(e=>{if(n[n.length-1]===e){n.pop()}if(o){if(o!==o.root()){o=o.up()}if(n.length<o._depth){o=o.root();(o._copyElement?s:l).push(o);o=null}}}));r.parse(t);if(l.length===0){return e}return l.map(((t,r)=>{const n=e.__clone();const o=t.root();for(let e=s.length-1;e>-1;e--){o.children.unshift(s[e])}n._raw=o.end({pretty});unrollIdxField.set(n,r);return n}))}catch(e){}return e};