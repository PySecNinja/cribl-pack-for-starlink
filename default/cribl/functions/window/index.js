exports.name="Window";exports.version="0.1.0";exports.disabled=false;exports.handleSignals=true;exports.group=C.INTERNAL_FUNCTION_GROUP;exports.sync=true;let logger;let eventWindow;let windowId;exports.init=n=>{logger=C.util.getLogger(`func:window`,{eventWindowId:n?.conf?.eventWindowId??"n/a"});if(n==null){logger.error("window pipeline function w/o configuration");throw new Error("window pipeline function requires a configuration")}const{eventWindowId:e,registeredFunctions:i,tailEventCount:o,headEventCount:t}=n?.conf??{};if(e==null){logger.error("required eventWindowId configuration missing",{opts:n});throw new Error("invalid configuration for window pipeline function")}if(!Array.isArray(i)||i.length<1){logger.error("required registeredFunctions configuration missing",{opts:n});throw new Error("invalid configuration for window pipeline function")}windowId=e;eventWindow=C.kusto.windowManager(e);if(eventWindow==null){logger.error("window manager couldn't establish event window",{eventWindowId:e});throw new Error("event window manager not established")}const r=/^(?<name>.+)\.as\((?<alias>.+)\)$/;i.forEach((n=>{logger.debug("registering function instance",{eventWindowId:e,funcEntry:n});const i=n.match(r);if(i){eventWindow.registerWindowFunctionInst(i[1],i[2])}else{eventWindow.registerWindowFunctionInst(n)}}));if(o)eventWindow.adjustTail(o);if(t)eventWindow.adjustHead(t);logger.debug("initialization complete",{eventWindowId:e,tailEventCount:o??0,headEventCount:t??0})};exports.process=n=>{if(!n)return n;if(n.__signalEvent__){logger.debug("received signal event",{signal:n.__signalEvent__});switch(n.__signalEvent__){case"reset":eventWindow.reset();return n;case"final":case"complete_gen":const e=eventWindow.flushHead();logger.debug("flushing head events to output",{numEvents:e?e.length:"n/p"});return[...e??[],n];default:return n}}return eventWindow.process(n)};exports.unload=()=>{if(windowId!=null){C.kusto.windowManager().destroyWindow(windowId)}};