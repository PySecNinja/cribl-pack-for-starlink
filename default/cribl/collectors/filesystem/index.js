exports.name="Filesystem";exports.version="0.1";exports.disabled=false;exports.destroyable=true;const fs=require("fs");const os=require("os");const _path=require("path");let dir;let recurse;let extractors;let filter;let provider;let batchSize;exports.init=e=>{const r=e.conf;dir=C.os.resolvepath(r.path);if(dir==null)return Promise.reject(new Error("path is required"));recurse=r.recurse||false;if(r.extractors){extractors={};const{Expression:e}=C.expr;r.extractors.forEach((r=>{extractors[r.key]=new e(r.expression)}))}filter=r.filter||"true";batchSize=r.maxBatchSize||10;provider=C.internal.Path.fileSystemProvider(recurse,dir);return provider.init()};function reportErrorIfAny(e,r){if(r==null)return;e.reportError(r).catch((()=>{}))}exports.discover=async e=>{const r=C.internal.Path.pathFilter(dir,filter,provider,e.logger(),extractors);let t=await r.getNextPath();reportErrorIfAny(e,r.getLastError());const s=[];while(!t.done){const o={source:t.val,size:t.meta.size};if(t.meta.fields)o.fields=t.meta.fields;if(t.val.endsWith(".gz"))o.compression="gzip";C.internal.Parquet.isParquetFile(t.val)?o.format="events":o.format="raw";s.push(o);if(s.length>=batchSize){await e.addResults(s);s.length=0}t=await r.getNextPath();reportErrorIfAny(e,r.getLastError())}await e.addResults(s)};exports.collect=async(e,r)=>new Promise(((t,s)=>{const o=e=>{s(e)};try{const s=provider.createReadStream(e,r);s.once("error",o);s.once("readable",(()=>{s.off("error",o);t(s)}))}catch(e){o(e)}}));exports.destroy=async e=>{await new Promise(((r,t)=>{fs.unlink(e.source,(e=>{if(e)return t(e);return r()}))}))};