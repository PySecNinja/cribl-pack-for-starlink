const{Expression,PartialEvalRewrite}=C.expr;exports.name="Script";exports.version="0.1";exports.disabled=false;exports.destroyable=false;const os=require("os");const{spawn}=require("child_process");const{constants,promises}=require("fs");const{pipe,SpawnGenerator}=C.internal.Generators;const{scopedResource}=C.internal;const accessAsync=promises.access;const host=os.hostname();let conf;let batchSize;let filter;let envVars;const requiredFields=["host","source"];exports.init=async e=>{conf=e.conf;batchSize=conf.maxBatchSize||10;filter=conf.filter||"true";envVars={};(conf.envVars||[]).forEach((e=>{envVars[e.name]=C.expr.runExprSafe(e.value)}));return Promise.resolve()};exports.discover=async e=>{const r=new Expression(filter,{disallowAssign:true,partialEval:new PartialEvalRewrite((e=>!requiredFields.includes(e)))});const o=conf.shell||"/bin/bash";try{await accessAsync(o,constants.X_OK)}catch(e){throw new Error(`Invalid shell, code: ${e.code}, errno: ${e.errno}, reason: ${e.message}`)}const s={...envVars,EARLIEST:conf.earliest,LATEST:conf.latest};const t=new SpawnGenerator({shell:o,cmd:conf.discoverScript,env:s});try{await scopedResource(pipe(t).byLines().map((e=>({host,source:e.trim(),format:"raw"}))).filteredBy(r).byChunksOf(batchSize).execute(),(async r=>{for await(const o of r){await e.addResults(o)}}))}catch(r){if(r.code!=null){e.logger().error("discover script failed",{exitCode:r.code,stderr:r.message});const o=C.internal.TaskError.createError({code:getTypeFromCode(r.code),errorInfo:r});throw o}throw r}};const errorCode2type={1:"TASK_FATAL",2:"TASK_FATAL",3:"TASK_RETRYABLE",4:"JOB_FATAL"};function getTypeFromCode(e){return e in errorCode2type?errorCode2type[e]:"TASK_FATAL"}const STDERR_SIZE=1024;exports.collect=async(e,r)=>{const o={...process.env,CRIBL_COLLECT_ARG:e.source,...envVars,EARLIEST:conf.earliest,LATEST:conf.latest};r.logger().debug("starting collect script",{source:e.source});const s=spawn(conf.shell||"/bin/bash",{env:o});s.stdin.end(conf.collectScript);let t="";let n="";s.stderr.on("data",(e=>{t+=e;t=t.slice(STDERR_SIZE);const r=n+e;n=r.slice(-STDERR_SIZE)}));s.on("exit",(o=>{if(o){const s="collect task failed";r.reportError(C.internal.TaskError.createError({type:getTypeFromCode(o),errorInfo:new Error(t+n)}));r.logger().error(s,{exitCode:o,source:e.source,error:t.toString()})}else r.logger().info("collect task completed",{exitCode:o,source:e.source})}));return new Promise(((e,r)=>{const o=e=>{r(e)};try{const r=s.stdout;r.once("error",o);r.once("readable",(()=>{r.off("error",o);e(r)}))}catch(e){o(e)}}))};