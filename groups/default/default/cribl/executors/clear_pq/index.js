exports.jobType="task-per-node";exports.name="clear_pq";const fs=require("fs");let outputId;const{util:{resolveEnvVars},internal:{PersistentQueue:{outputPath,orphanAssignments}}}=C;exports.initJob=async t=>{const{conf:s}=t.conf.executor;outputId=s.outputId};exports.jobSeedTask=async()=>({task:{outputId}});exports.initTask=async t=>{};exports.jobOnError=async(t,s,e)=>{};exports.taskExecute=async(t,s)=>{const e=t.logger();e.info("task opts",{opts:s});const o=outputPath(s.outputId);if(!o)throw{message:"Misconfigured persistent queue path"};const r=resolveEnvVars(o);const n=await fs.promises.readdir(r);if(n.length>0){await Promise.all(n.map((async t=>{const o=`${r}/${t}/${s.outputId}`;e.debug("deleting path",{path:o});return fs.promises.rm(o,{recursive:true,force:true})})))}const a=await orphanAssignments();e.debug("orphans",{assignedPaths:a});if(a.length>0){await Promise.all(a.map((t=>{const o=`${t}/${s.outputId}`;e.debug("deleting orphan",{path:o});return fs.promises.rm(o,{recursive:true,force:true})})))}};