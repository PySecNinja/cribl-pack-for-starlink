const{NestedPropertyAccessor}=C.expr;exports.disabled=0;exports.name="Serialize";exports.version="0.2";exports.group="Formatters";exports.sync=true;let conf={};let srcField;let dstField;let serde;let fieldFilter;class FieldFilter{constructor(e){this.keepFields=e}shouldKeep(e,i,r){return!this.keepFields||this.keepFields.test(i)}}exports.init=e=>{conf=(e||{}).conf||{};dstField=(conf.dstField||"_raw").trim();srcField=(conf.srcField||"").trim();dstField=new NestedPropertyAccessor(dstField);srcField=srcField.length===0?undefined:new NestedPropertyAccessor(srcField);const i=(conf.fields||[]).map((e=>e.trim())).filter((e=>e.length));if(!i.length&&["clf","elff","csv"].indexOf(conf.type)>-1){throw new Error("'Fields to serialize' is required when an order dependent serialization type is specified.")}if(!i.length){i.push("!__*","*")}const r=new C.util.WildcardList([...i,"!*"]);fieldFilter=new FieldFilter(r);if(conf.type==="elff"){serde=C.Text._elffSerDe({fields:i},fieldFilter)}else if(conf.type==="clf"){serde=C.Text._clfSerDe({fields:i},fieldFilter)}else if(conf.type==="csv"){serde=C.Text._delimSerDe({fields:i},fieldFilter)}else if(conf.type==="delim"){serde=C.Text._delimSerDe({delimiter:conf.delimChar,escapeChar:conf.escapeChar,quoteChar:conf.quoteChar,nullValue:conf.nullValue,fields:conf.fields||[]},fieldFilter)}else if(conf.type==="kvp"){serde=C.Text._kvpSerDe(fieldFilter,conf.cleanFields,undefined,undefined,conf.pairDelimiter)}else if(conf.type==="json"){serde=C.Text._jsonSerDe(fieldFilter)}else{throw new Error(`unknown type=${conf.type}`)}};function serialize(e){const i=srcField?srcField.get(e):e;if(i){dstField.set(e,serde.serialize(i,true))}return e}exports.process=serialize;