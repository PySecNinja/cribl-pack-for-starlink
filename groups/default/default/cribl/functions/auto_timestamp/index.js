exports.name="Auto Timestamp";exports.version="1.2";exports.cribl_version="1.6.0";exports.disabled=false;exports.group="Standard";exports.sync=true;const{Expression,NestedPropertyAccessor}=C.expr;const{NamedGroupRegExp}=C.util;const cLogger=C.util.getLogger("func:auto_timestamp");let conf={};let parser;let lastEventTime;let srcOffset;let srcEnd;exports.init=e=>{conf=Object.assign({},(e||{}).conf||{});conf.maxLen=conf.maxLen||150;conf.timestamps=conf.timestamps||[];conf.srcField=new NestedPropertyAccessor(conf.srcField||"_raw");conf.dstField=new NestedPropertyAccessor(conf.dstField||"_time");const s=conf.timeExpression||"time.getTime() / 1000";conf.timeExpression=new Expression(s,{disallowAssign:true,args:["time"]});conf.timestamps=(conf.timestamps||[]).map((e=>({regex:new NamedGroupRegExp(e.regex),parser:C.Time.getParserWithTzInfo(e.strptime,conf.defaultTimezone)})));parser=C.Time._timestampFinder(conf.defaultTimezone);lastEventTime=undefined;conf.defaultTime=conf.defaultTime||"now";srcOffset=conf.offset||0;srcEnd=srcOffset+conf.maxLen};exports.process=e=>{let s=conf.srcField.get(e);s=s&&s.toString().substring(srcOffset,srcEnd);let t;for(let e=0;s&&e<conf.timestamps.length;e++){const n=conf.timestamps[e].regex.exec(s);if(n&&n[1]){t=conf.timestamps[e].parser(n[1]);if(t){break}}}const n=C.Time.parseRelativeTime(conf.earliestDateAllowed||C.Time.EARLIEST_DATE_RANGE);const o=C.Time.parseRelativeTime(conf.latestDateAllowed||C.Time.LATEST_DATE_RANGE);t=t||s&&parser.find(s);t=C.Time.clamp(t,n,o,undefined);if(t){lastEventTime=t;conf.dstField.set(e,conf.timeExpression.evalOn(e,t))}else if(conf.defaultTime==="last"&&lastEventTime){conf.dstField.set(e,conf.timeExpression.evalOn(e,lastEventTime))}else if(conf.defaultTime==="now"){conf.dstField.set(e,conf.timeExpression.evalOn(e,new Date))}return e};