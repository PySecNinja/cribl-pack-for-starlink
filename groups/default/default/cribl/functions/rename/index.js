exports.name="Rename";exports.version="0.1";exports.disabled=false;exports.group="Standard";exports.sync=true;const{Expression,NestedPropertyAccessor}=C.expr;const criblInternalField=C.internal.criblInternalField;const cLogger=C.util.getLogger("func:rename");const DEFAULT_DEPTH=5;let fields2rename=[];let renameExpr;let baseFields=[];let baseWCFields=null;let wildcardDepth;let internalBaseFieldsRemoved=false;function getAccessor(e){return new NestedPropertyAccessor(e)}function rename(e,n,r){if(typeof e!=="object"||typeof n!=="object")return;if(e.path===n.path)return;const t=e.get(r);if(t===undefined)return;n.set(r,e.get(r));e.set(r,undefined)}function parseExpr(e){if(!e)return undefined;return new Expression(`${e}`,{disallowAssign:true,args:["name","value"]})}function renameFieldsOn(e,n){if(e==null||typeof e!=="object")return;for(let n=1;n<fields2rename.length;n+=2){rename(fields2rename[n-1],fields2rename[n],e)}if(renameExpr){for(const[r,t]of Object.entries(e)){if(!criblInternalField(r)){const s=renameExpr.evalOn(n,r,t);if(s!=null&&r!==s&&!criblInternalField(s)){e[s]=e[r];e[r]=undefined}}}}}const isInternalField=e=>criblInternalField(e.replace(/^["']/,""));exports.init=e=>{const n=e.conf;fields2rename=[];baseFields=[];baseWCFields=null;const r=[];const t=[];(n.rename||[]).forEach((e=>{if(isInternalField(e.currentName)||isInternalField(e.newName)){t.push(`${e.currentName} -> ${e.newName}`)}else{r.push(getAccessor((e.currentName||"").trim()));r.push(getAccessor((e.newName||"").trim()))}}));if(t.length>0){cLogger.warn("Ignoring internal fields in rename function",{ignoredFieldPairs:t})}fields2rename=r;const s=[];const i=[];const l=n.baseFields||[];for(let e=0;e<l.length;e++){const n=l[e].trim();if(isInternalField(n)){internalBaseFieldsRemoved=true;cLogger.warn(`Ignoring internal field ${n} in rename function parent fields`)}else if(n.length>0){if(n.includes("*")){i.push(n)}else{s.push(n)}}}if(i.length>0){baseWCFields=new C.util.WildcardList([...new Set(i)]);wildcardDepth=n.wildcardDepth==null?DEFAULT_DEPTH:Number(n.wildcardDepth);if(isNaN(wildcardDepth)||wildcardDepth<0){throw new Error("wildcardDepth must be a positive integer value")}}baseFields=[...new Set(s)].filter((e=>!baseWCFields||!baseWCFields.test(e))).map(getAccessor);renameExpr=parseExpr(n.renameExpr)};exports.process=e=>{if(!e)return e;if(fields2rename.length===0&&!renameExpr)return e;if(baseFields.length===0&&baseWCFields==null&&!internalBaseFieldsRemoved){renameFieldsOn(e,e)}else{for(let n=0;n<baseFields.length;n++){renameFieldsOn(baseFields[n].get(e),e)}if(baseWCFields){e.__traverseAndUpdate(wildcardDepth,((n,r)=>{if(baseWCFields.test(n)){renameFieldsOn(r,e)}return r}))}}return e};