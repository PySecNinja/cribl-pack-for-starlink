exports.name="Database";exports.version="0.1";exports.disabled=false;exports.destroyable=false;const stream=require("stream");let conf;let queryExpression;const isSelect=e=>{const t=e.split(";");if(t.length>2||t.length===2&&t[1].trim()!==""){return false}return e.trim().toLowerCase().startsWith("select")};class StateReportingTransform extends stream.Transform{constructor(e,t,r){super({objectMode:true,...e});this.job=t;this.state=r}_transform(e,t,r){if(!Object.hasOwn(e,conf.stateTracking.trackingColumn)){this.destroy(`Tracking column "${conf.stateTracking.trackingColumn}" was missing from row`);return}const n=e[conf.stateTracking.trackingColumn];if(typeof n!=="number"&&typeof n!=="string"){this.job.logger().error("Invalid row value for tracking column, must be a number or string",{valueType:typeof n,column:conf.stateTracking.trackingColumn});this.destroy(`Tracking column "${conf.stateTracking.trackingColumn}" contained non-number/non-string value`);return}this.state[conf.stateTracking.trackingColumn].value=n;this.job.reportState(this.state);this.push(e);r()}_flush(e){this.job.logger().debug("State after processing results",{state:this.state});e()}}exports.metricDims=()=>{const e=conf.connectionId;const t=C.internal.DatabaseConnectionsMgr.instance();return{databaseType:t.getDatabaseType(e)}};exports.UT_getAllMetricDims=()=>{const e=C.internal.DatabaseConnectionsMgr.instance();const t=[];for(const r of e.getDatabaseTypes()){t.push({databaseType:r})}return t};exports.init=async e=>{const{Expression:t}=C.expr;conf=e.conf||{};queryExpression=new t(conf.query,{disallowAssign:true});if((conf.queryValidationEnabled??true)&&!isSelect(queryExpression.evalOn({}))){throw new Error("Invalid config - Must provide only a single SELECT query")}};exports.discover=async e=>{await e.addResult({format:"raw",stateKey:"databaseCollectorState"})};exports.collect=async(e,t)=>{const r=conf.connectionId;const n=C.internal.DatabaseConnectionsMgr.instance();let s;try{s=n.getConnection(r,t.logger())}catch(e){t.reportError(e)}if(s==null){throw new Error(`Can't find Database Connection '${r}'`)}let a=e.state;const o=s.prepareStatement(queryExpression,a);if(o){const e={};try{const r=o.preparedStatement;const n=o.referencedVariables;for(const t of n){if(t==="earliest"){e["earliest"]=new Date(isNaN(+conf.earliest)?Date.now():conf.earliest*1e3).toISOString()}else if(t==="latest"){e["latest"]=new Date(isNaN(+conf.latest)?Date.now():conf.latest*1e3).toISOString()}else{e[t]=a[t].value}}t.logger().debug("Query",{preparedStatement:r,args:e});let i=await s.executeQuery(r,a,e);if(conf.stateTracking?.enabled){if(!a){a={[conf.stateTracking.trackingColumn]:{value:null}}}t.logger().debug("State before processing results",{state:a});const e=new StateReportingTransform({},t,a);i=stream.pipeline(i,e,(()=>{}))}const c=await C.internal.stringifyReadableObjects(i);return c}catch(e){t.reportError(new Error("Collect error",{err:e})).catch((()=>{}));throw e}}else{t.reportError(new Error("Unable to prepare statement",{queryExpression})).catch((()=>{}))}};