output: default
streamtags: []
groups:
  xhsgQh:
    name: Optional Event Optimization
    description: Toggle this group on to drop, sample, or suppress events before
      further processing
    disabled: true
    index: 3
asyncFuncTimeout: 1000
functions:
  - id: comment
    filter: "true"
    disabled: null
    conf:
      comment: >-
        This pipeline transforms Edge Windows Events from XML to a
        simplified/flat JSON structure.  This allows you to take advantage of
        Edge's better XML collection performance, but prefer JSON.  Can be used
        as is for destinations that support it, or it can be a great starting
        point for your own custom event.


        An included optional function group can be enabled below where event level optimization is required.  You will need to modify the knowledge object WEL_EventIDs_2_Optimize.csv, ensuring the event ID's along with how you'd like them handled (this supports drop, sample, or suppress OOTB).


        Use the corresponding XML labeled sample files included in this pack for testing this pipeline.
  - id: comment
    filter: "true"
    disabled: null
    conf:
      comment: "IMPORTANT:  Select the three grey bars ||| top left and enable the
        Description option"
  - id: comment
    filter: "true"
    disabled: null
    conf:
      comment: Toggle the below function group to optimize windows events by ID
  - id: regex_extract
    filter: "true"
    disabled: true
    conf:
      source: _raw
      iterations: 100
      overwrite: false
      regex: /<EventID>(?<__eventid>[\d]+)<\/EventID>/
    description: let's snag the event ID if we're going to optimize (let's get rid
      of stuff we before we spend time processing further)
    groupId: xhsgQh
  - id: lookup
    filter: "true"
    disabled: true
    conf:
      matchMode: exact
      reloadPeriodSec: -1
      addToEvent: false
      inFields:
        - eventField: __eventid
          lookupField: EventID
      ignoreCase: false
      file: WEL_EventIDs_2_Optimize.csv
      outFields:
        - lookupField: Action
          eventField: __optimize_action
    groupId: xhsgQh
    description: modify this lookup to add events to drop, sample, or suppress
  - id: drop
    filter: __optimize_action=='drop'
    disabled: true
    conf: {}
    groupId: xhsgQh
  - id: sampling
    filter: __optimize_action=='sample'
    disabled: true
    conf:
      rules:
        - filter: __eventid
          rate: 10
    groupId: xhsgQh
  - id: suppress
    filter: __optimize_action=='suppress'
    disabled: true
    conf:
      allow: 2
      suppressPeriodSec: 30
      dropEventsMode: true
      maxCacheSize: 50000
      cacheIdleTimeoutPeriods: 2
      numEventsIdleTimeoutTrigger: 10000
      keyExpr: __eventid
    groupId: xhsgQh
  - id: comment
    filter: "true"
    disabled: null
    conf:
      comment: Parse _raw XML to JSON & clean up whitespace
  - id: eval
    filter: "true"
    disabled: null
    conf:
      add:
        - disabled: false
          name: _raw
          value: C.Text.parseWinEvent(_raw,[])
    final: false
    description: Convert XML to JSON and cleanup
  - id: code
    filter: "true"
    disabled: false
    conf:
      maxNumOfIterations: 5000
      activeLogSampleRate: 1
      useUniqueLogChannel: false
      code: >-
        // Function to flatten nested objects and clean up whitespace

        function flattenAndClean(obj) {
          // Resulting flattened object
          const result = {};

          // Recursive function to process nested objects
          function processObject(current, prop) {
            // If the current element is not an object (leaf node)
            if (Object(current) !== current) {
              // Extract the last part of the property path as the new key
              const newKey = prop.split('.').pop();

              // Assign the trimmed value to the new key in the result object
              result[newKey] = typeof current === 'string' ?
                (current.includes('\n') ? current.replace(/\n\s\s+/g, '\n').split('\n') : current.trim()) :
                current;
            } else if (Array.isArray(current)) {
              // If the current element is an array, process its elements
              for (let i = 0, l = current.length; i < l; i++) {
                // Recursively process each element in the array
                processObject(current[i], prop + '[' + i + ']');
              }

              // If the array is empty, create an empty array at the specified property
              if (l === 0) {
                const newKey = prop.split('.').pop();
                result[newKey] = [];
              }
            } else {
              // If the current element is an object, process its properties
              let isEmpty = true;
              for (let p in current) {
                // Recursively process each property in the object
                isEmpty = false;
                processObject(current[p], prop ? prop + '.' + p : p);
              }

              // If the object is empty, create an empty object at the specified property
              if (isEmpty && prop) {
                const newKey = prop.split('.').pop();
                result[newKey] = {};
              }
            }
          }

          // Start the recursion with the initial object and an empty property path
          processObject(obj, '');

          // Return the flattened result object
          return result;
        }


        // Initialize error field

        __e['cribl_code_error'] = [];


        try {
          // Assuming __e['_raw'] contains nested JSON data
          const nestedJson = __e['_raw'];

          // Flatten and clean the provided nested JSON
          const flattenedData = flattenAndClean(nestedJson);

          // Deduplicate keys and convert them to arrays if needed
          const deduplicatedData = {};
          for (const key in flattenedData) {
            if (deduplicatedData[key] === undefined) {
              deduplicatedData[key] = flattenedData[key];
            } else {
              if (!Array.isArray(deduplicatedData[key])) {
                deduplicatedData[key] = [deduplicatedData[key]];
              }
              deduplicatedData[key].push(flattenedData[key]);
            }
          }

          // Update __e['_raw'] with the processed data
          __e['_raw'] = deduplicatedData;
        } catch (error) {
          // Log errors
          __e['cribl_code_error'].push(String(error));
        }


        // Display error field if there are errors

        if (__e['cribl_code_error'].length > 0) {
          __e['cribl_code_error'];
        } else {
          delete __e['cribl_code_error'];
        }
    final: false
    description: Convert nested JSON to top level JSON, credit to Amazin' Maislin
