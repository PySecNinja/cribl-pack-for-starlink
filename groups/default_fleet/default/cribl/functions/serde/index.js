const{Expression,NestedPropertyAccessor}=C.expr;exports.disabled=0;exports.name="Parser";exports.version="0.4";exports.group="Standard";exports.sync=true;let conf={};let srcField="_raw";let dstField;let serde;let fieldFilter;class FieldFilter{constructor(e,r,t){this.keepFields=e;this.removeFields=r;this.fieldFilterExpr=t}shouldKeep(e,r,t){if(this.keepFields&&this.keepFields.test(r)){return true}if(this.removeFields&&this.removeFields.test(r)){return false}return!this.fieldFilterExpr||this.fieldFilterExpr.evalOn({index:t,name:r,value:e})}}exports.init=e=>{conf=(e||{}).conf||{};srcField=new NestedPropertyAccessor((conf.srcField||"_raw").trim());dstField=(conf.dstField||"").trim();if(dstField){dstField=new NestedPropertyAccessor(dstField)}const r=(conf.keep||[]).map((e=>e.trim())).filter((e=>e.length));let t=(conf.remove||[]).map((e=>e.trim())).filter((e=>e.length));let i;if(r.length>0){i=new C.util.WildcardList(r)}if(r.length>0&&t.length===0&&(conf.fieldFilterExpr===undefined||conf.fieldFilterExpr.length===0)){t=["*"]}let l;if(t.length>0){l=new C.util.WildcardList(t)}const s=conf.fieldFilterExpr&&new Expression(`${conf.fieldFilterExpr}`,{disallowAssign:true});fieldFilter=new FieldFilter(i,l,s);if(conf.type==="elff"){serde=C.Text._elffSerDe({fields:conf.fields||[]},fieldFilter)}else if(conf.type==="clf"){serde=C.Text._clfSerDe({fields:conf.fields||[]},fieldFilter)}else if(conf.type==="csv"){serde=C.Text._delimSerDe({fields:conf.fields||[]},fieldFilter)}else if(conf.type==="delim"){serde=C.Text._delimSerDe({delimiter:conf.delimChar,escapeChar:conf.escapeChar,quoteChar:conf.quoteChar,nullValue:conf.nullValue,fields:conf.fields||[]},fieldFilter)}else if(conf.type==="kvp"){serde=C.Text._kvpSerDe(fieldFilter,conf.cleanFields,conf.allowedKeyChars,conf.allowedValueChars)}else if(conf.type==="json"){serde=C.Text._jsonSerDe(fieldFilter)}else if(conf.type==="regex"){if(C.Text._regexSerDe==null){throw new Error(`type =${conf.type} not supported`)}serde=C.Text._regexSerDe(conf)}else if(conf.type==="grok"){if(C.Text._grokSerDe==null){throw new Error(`type =${conf.type} not supported`)}serde=C.Text._grokSerDe(conf,C.GrokRule)}else{throw new Error(`unknown type=${conf.type}`)}if(conf.mode==="reserialize"){exports.process=reserialize}else{exports.process=extract}if(serde.init){return serde.init(conf)}};function extract(e){const r=srcField.get(e);let t=e;if(dstField){t={};dstField.set(e,t)}serde.deserialize(r,t);return e}function reserialize(e){const r=srcField.get(e);(dstField||srcField).set(e,serde.reserialize(r));return e}exports.process=extract;