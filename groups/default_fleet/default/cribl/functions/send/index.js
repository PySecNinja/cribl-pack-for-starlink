exports.name="send";exports.version="0.0.2";exports.disabled=false;exports.handleSignals=true;exports.asyncTimeout=-1;exports.group=C.INTERNAL_FUNCTION_GROUP;const{randomBytes}=require("crypto");let url,group="default",workspace="main",sendUrlTemplate,searchId,tee=false,flushMs=1e4,destination,lastFlush,logger,_eventsOut=0,_eventsDropped=0,_bytesOut=0,suppressPreviews=false,receivedEvents=false,sendId=`${Date.now()}${randomBytes(4).toString("hex")}`;exports.init=async e=>{const t=e.conf;({url,searchId,sendUrlTemplate}=t);if(!searchId)throw new Error("searchId field is required");if(!sendUrlTemplate)throw new Error("sendUrlTemplate field is required");logger=C.util.getLogger(`sendFunction:${searchId}`);group=t.group??group;workspace=t.workspace??workspace;sendUrlTemplate=t.sendUrlTemplate??sendUrlTemplate;tee=t.tee??tee;flushMs=t.flushMs??flushMs;suppressPreviews=t.suppressPreviews;if(!url){url=templateStr(sendUrlTemplate,{workspace,group})}destination=await C.internal.kusto.send.createDestination({url,searchId});_eventsOut=0;_bytesOut=0;_eventsDropped=0;logger.info("Initialized send",{url,tee,searchId})};exports.process=async e=>{if(!tee&&e.__signalEvent__){switch(e.__signalEvent__){case"reset":case"complete_gen":return;case"timer":return flushStats(e);case"close":return flushStats(e);case"final":{if(e.__ctrlFields.includes("cancel"))return e;logger.debug("Final flushing stats & destination");await destination.flush();await destination.close();const t=createStatsEvent(e,destination,true);t.status="Sending complete";return[e,t]}default:logger.warn("unhandled signal",{event:e});return e}}return await send(e,destination,tee)};exports.unload=()=>{destination=undefined;url=undefined;receivedEvents=false};async function send(e,t,s=false){if(s){if(e.__signalEvent__)return e;const s=e.__clone();await t.send(s);return e}await t.send(e);return flushStats(e)}function templateStr(e,t){return e.replace(/<\w+>/g,(e=>{const s=e.slice(1,-1);const n=t[s];if(!n){throw new Error(`Unknown replace token ${s}`)}return n}))}function createStatsEvent(e,t,s=false){const n=t.reportStatus();const r=e.__clone(true,[]);const{sentCount:a,bytesOut:o,numDropped:u}=n.metrics;const l=a-_eventsOut;const i=o-_bytesOut;const d=u-_eventsDropped;if(!s&&i===0&&l===0&&d===0)return undefined;const c=Object.assign(r,{sendId,url,searchId,eventsOut:l,totalEventsOut:a,bytesOut:i,totalBytesOut:o,eventsDropped:d,totalEventsDropped:u,status:"Sending",_time:Date.now()/1e3});_eventsOut=a;_bytesOut=i;_eventsDropped=u;return c}function flushStats(e){const t=[];if(!receivedEvents){receivedEvents=true;const s=e.__clone(true,[]);const n=Object.assign(s,{searchId,sendId,url,status:"Begin sending",group,workspace,_time:Date.now()/1e3});t.push(n)}if(e.__signalEvent__){t.push(e)}const s=Date.now();if(!lastFlush)lastFlush=s;if(!suppressPreviews&&lastFlush+flushMs<s){logger.debug("timer flushing stats");const n=createStatsEvent(e,destination);lastFlush=s;n&&t.push(n)}return t.length?t:undefined}exports.UT_getDestination=()=>destination;