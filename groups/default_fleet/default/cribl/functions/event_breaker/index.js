exports.name="Event Breaker";exports.version="0.2";exports.group="Advanced";exports.disabled=false;exports.sync=true;const dLogger=C.util.getLogger("func:event_breaker");const{except}=C.util;const CHANNEL="__channel";const DEFAULT_CHANNEL="__EVENT_BREAKER_FUNC";let rule;let existingRule;let isExistingRule;let getBreakerCache;let shouldMarkCriblBreaker;exports.init=e=>{const{EventBreakerRule:r,BreakerMgr:t}=C.internal.Breakers;const i=e.conf||{};getBreakerCache={};dLogger.info("Initializing function with conf",i);t.instance()?.on("update",(e=>{if(e in getBreakerCache){dLogger.debug(`Reset cache for ${e}`);delete getBreakerCache[e]}}));existingRule=i.existingRule;isExistingRule=i.existingOrNew==="existing";shouldMarkCriblBreaker=i.shouldMarkCriblBreaker??true;if(!isExistingRule){let e={...i,type:i.ruleType,name:"event_breaker_func",condition:true};e=except(["ruleType","existingRule","existingOrNew","shouldMarkCriblBreaker"],e);rule=r.from(e,shouldMarkCriblBreaker)}};exports.process=e=>{const{getBreaker:r}=C.internal.Breakers;if(e._raw==null){dLogger.debug(`Found event without _raw, skipping breaker`);return e}if(isExistingRule){if(existingRule in getBreakerCache&&getBreakerCache[existingRule].appliesTo(e)){dLogger.debug("Found rule in cache");rule=getBreakerCache[existingRule]}else{const t=r(existingRule);rule=t.getBreakerFor(e,true,shouldMarkCriblBreaker);getBreakerCache[existingRule]=rule}}if(rule==null){return e}const t=[];if(!e[CHANNEL]){e[CHANNEL]=DEFAULT_CHANNEL}const i=rule.break(e,true);if(i.length===0){return e}for(let e=0;e<i.length;e++){t.push(i[e])}return t.length===1?t[0]:t};exports.unload=()=>{rule=undefined;isExistingRule=false;getBreakerCache={};shouldMarkCriblBreaker=undefined};exports.UT_getRule=()=>rule;exports.UT_getBreakerCache=()=>getBreakerCache;