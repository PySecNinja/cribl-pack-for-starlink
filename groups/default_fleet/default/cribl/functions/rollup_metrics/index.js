exports.name="Rollup Metrics";exports.version="0.1";exports.group="Advanced";exports.handleSignals=true;exports.sync=true;let dimFilter;let timeWindow;let rollup;let nextFlushTime;exports.init=e=>{const t=e.conf||{};timeWindow=C.util.parseTimeStringToSeconds(t.timeWindow||"60s");const i=(t.dimensions||[]).map((e=>e.trim())).filter((e=>e.length));if(i.length===0)i.push("*");if(i.length===1&&i[0]==="*"){dimFilter=undefined}else{const e=new C.util.WildcardList(i);dimFilter=e.test.bind(e)}rollup=new C.internal.MetricsRollup(t.gaugeRollup,dimFilter);nextFlushTime=Date.now()+timeWindow*1e3};exports.process=e=>{const t=e.__signalEvent__;if(["close","final"].includes(t)||Date.now()>nextFlushTime){nextFlushTime+=timeWindow*1e3;const t=rollup.add(e);const i=rollup.output();if(!t)i.push(e);return i.length===1?i[0]:i}if(t)return e;if(rollup.add(e))return undefined;return e};